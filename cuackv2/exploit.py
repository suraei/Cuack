import subprocess
import os
from utils import print_info, print_success, print_error
import xml.etree.ElementTree as ET

def extraer_productos_versiones(xml_file):
    productos_versiones = set()

    tree = ET.parse(xml_file)
    root = tree.getroot()

    for service in root.findall(".//service"):
        product = service.get('product')
        version = service.get('version')
        if product and version:
            productos_versiones.add((product, version))
        elif product:
            productos_versiones.add((product, ''))

    return productos_versiones

def obtener_exploits_disponibles(producto, version):
    # Construye el comando considerando si hay una versión específica
    command = f"searchsploit {producto} {version} --disable-colour -w" if version else f"searchsploit {producto} -w --disable-colour"
    result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, text=True)
    
    # Filtra solo los resultados de exploits disponibles
    exploits = []
    lines = result.stdout.splitlines()
    exploit_block = False
    for line in lines:
        if line.strip().startswith("Exploit Title"):
            exploits.append(line)
            exploit_block = True
        elif exploit_block and line.strip() == "":
            exploit_block = False
        elif exploit_block:
            exploits.append(line)
    
    return "\n".join(exploits)

def guardar_resultados_en_archivo(resultados, archivo):
    with open(archivo, "a") as file:
        file.write(resultados)

def run_searchsploit(nmap_xml_file, results_directory, domain):
    productos_versiones = extraer_productos_versiones(nmap_xml_file)
    contenido_a_guardar = ""  # Inicializa una variable para acumular la salida que potencialmente se guardará

    print_info("Buscando exploits conocidos para los servicios identificados...")

    for producto, version in productos_versiones:
        exploits_disponibles = obtener_exploits_disponibles(producto, version)
        if exploits_disponibles:
            contenido_a_guardar += f"Searchsploit para: {producto} {version}\n{exploits_disponibles}\n"
            print_error(f"Posible exploit para: {producto} {version}")
        else:
            print_error(f"No se encontraron exploits para: {producto} {version}")

    # Si después de iterar no hay contenido relevante, imprime un mensaje y no crea el archivo
    if contenido_a_guardar.strip() == "":
        print_error("No se encontraron exploits relevantes para ninguno de los servicios.")
    else:
        # Si se encontraron exploits, guarda la salida en el archivo
        output_file = os.path.join(results_directory, f"exploits.txt")
        guardar_resultados_en_archivo(contenido_a_guardar, output_file)
        
        # También agrega los resultados a discover_results.txt
        discover_results_file = os.path.join(results_directory, "reporte_descubrimiento.txt")
        guardar_resultados_en_archivo("\nExploits Disponibles:\n" + contenido_a_guardar, discover_results_file)
        
        print_success(f"Resultados de Searchsploit guardados en {output_file}")

